<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Musical Bouncing Balls</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #0f172a;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        /* Custom switch styling */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
            flex-shrink: 0;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #334155;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #3b82f6;
        }
        input:checked + .slider:before {
            transform: translateX(16px);
        }
    </style>
</head>
<body class="h-screen flex flex-col md:flex-row">

    <!-- Controls Sidebar -->
    <div class="w-full md:w-80 bg-slate-800 p-6 flex flex-col gap-6 shadow-xl z-10 overflow-y-auto" style="min-width: 320px;">
        <div>
            <h1 class="text-2xl font-bold text-blue-400 mb-2">Rhythm Balls V2.1</h1>
            <p class="text-sm text-slate-400">Balls gate the music on impact.</p>
        </div>

        <!-- Audio Section -->
        <div class="bg-slate-700/50 p-4 rounded-xl border border-slate-600">
            <h2 class="font-semibold mb-3 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>
                Music Source
            </h2>
            <input type="file" id="audioInput" accept="audio/*" class="block w-full text-sm text-slate-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600 mb-2"/>
            <p id="audioStatus" class="text-xs text-yellow-400">Upload a song to start</p>
             <div class="mt-4">
                <label class="text-sm text-slate-300 block mb-1 flex justify-between">
                    <span>Master Volume</span>
                    <span id="volValue">50%</span>
                </label>
                <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5" class="w-full accent-blue-500">
            </div>
        </div>

        <!-- Modes Section -->
        <div class="bg-slate-700/50 p-4 rounded-xl border border-slate-600 flex-grow">
            <h2 class="font-semibold mb-4 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-green-400"><path d="M12 2v4"/><path d="m16.2 7.8 2.9-2.9"/><path d="M18 12h4"/><path d="m16.2 16.2 2.9 2.9"/><path d="M12 18v4"/><path d="m4.9 19.1 2.9-2.9"/><path d="M2 12h4"/><path d="m4.9 4.9 2.9 2.9"/></svg>
                Impact Modes
            </h2>
            
            <div class="space-y-4">
                <div class="flex items-center justify-between">
                    <div class="flex flex-col">
                        <span class="text-sm font-medium">No Friction</span>
                        <span class="text-xs text-slate-400">Bounce forever</span>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="modeNoFriction">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="flex items-center justify-between">
                    <div class="flex flex-col">
                        <span class="text-sm font-medium">Super Bounce</span>
                        <span class="text-xs text-slate-400">Gain energy on hit</span>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="modeBounce">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="flex items-center justify-between">
                    <div class="flex flex-col">
                        <span class="text-sm font-medium">Speed Up</span>
                        <span class="text-xs text-slate-400">Faster every hit</span>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="modeSpeed">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="flex items-center justify-between">
                    <div class="flex flex-col">
                        <span class="text-sm font-medium">Grow</span>
                        <span class="text-xs text-slate-400">Get bigger on hit</span>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="modeGrow">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="flex items-center justify-between">
                    <div class="flex flex-col">
                        <span class="text-sm font-bold text-purple-300">Multiply</span>
                        <span class="text-xs text-slate-400">Split on strong hits</span>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="modeMultiply">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Actions -->
        <div class="flex flex-col gap-2">
            <button id="startBtn" class="w-full py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl transition flex items-center justify-center gap-2">
                Start / Add Ball
            </button>
            <button id="clearBtn" class="w-full py-2 bg-slate-700 hover:bg-red-500/20 text-slate-300 hover:text-red-300 font-semibold rounded-xl transition">
                Clear All Balls
            </button>
        </div>
        <div class="text-center text-xs text-slate-500" id="ballCount">
            Balls: 0 (Max 200)
        </div>
    </div>

    <!-- Canvas Container -->
    <div class="flex-grow relative bg-slate-900">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
        <div id="tutorial" class="pointer-events-none absolute inset-0 flex items-center justify-center bg-black/50 transition-opacity duration-500 opacity-100">
            <div class="text-center p-6 bg-slate-800 rounded-2xl border border-slate-600 shadow-2xl max-w-md mx-4">
                <h3 class="text-xl font-bold text-white mb-2">Rhythm Balls V2.1</h3>
                <p class="text-slate-300 mb-4">1. Upload a song.<br>2. Click Start to drop balls.<br>3. Music plays only when balls bounce!</p>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let balls = [];
        const MAX_BALLS = 200; 
        
        // Adjusted Physics for better "off" state feel
        const GRAVITY = 0.4;
        const FRICTION = 0.98;      // More air resistance so they don't feel like they are speeding up naturally
        const BASE_BOUNCE = 0.6;    // Lose more energy by default
        const SUPER_BOUNCE = 1.15;  // Gain energy when active

        let modes = {
            noFriction: false,
            superBounce: false,
            speedUp: false,
            grow: false,
            multiply: false
        };

        // --- New Audio Engine (Gated Loop) ---
        let audioCtx = null;
        let audioBuffer = null;
        let sourceNode = null;    // The continuously looping song
        let gateNode = null;      // The gate that opens on impact
        let masterGain = null;    // Volume slider control
        let isPlaying = false;

        // --- Setup ---
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Audio Handling ---
        async function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                masterGain = audioCtx.createGain();
                masterGain.connect(audioCtx.destination);
                
                gateNode = audioCtx.createGain();
                gateNode.gain.value = 0.0; // Start silent
                gateNode.connect(masterGain);

                updateVolume();
            }
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
        }

        function startBackgroundLoop() {
            if (!audioCtx || !audioBuffer || isPlaying) return;
            
            // Stop old source if it exists somehow
            if (sourceNode) { try { sourceNode.stop(); } catch(e) {} }

            sourceNode = audioCtx.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.loop = true;
            sourceNode.connect(gateNode);
            sourceNode.start(0);
            isPlaying = true;
        }

        document.getElementById('audioInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const status = document.getElementById('audioStatus');
            status.textContent = "Loading... wait.";
            status.className = "text-xs text-blue-400 loading-pulse";

            if (isPlaying && sourceNode) {
                sourceNode.stop();
                isPlaying = false;
            }

            try {
                await initAudio();
                const arrayBuffer = await file.arrayBuffer();
                audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                status.textContent = `Ready: ${file.name.substring(0, 25)}`;
                status.className = "text-xs text-green-400";
                // We don't auto-start here; wait for user interaction (browser policy best practice)
            } catch (err) {
                status.textContent = "Error loading audio.";
                status.className = "text-xs text-red-400";
                console.error(err);
            }
        });

        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            updateVolume();
            document.getElementById('volValue').textContent = Math.round(e.target.value * 100) + '%';
        });

        function updateVolume() {
            if (masterGain) {
                masterGain.gain.value = document.getElementById('volumeSlider').value;
            }
        }

        // The new impact sound just opens the gate for a moment
        function openAudioGate(intensity = 1) {
            if (!audioCtx || !gateNode) return;
            
            // Ensure loop is running if it hasn't started yet
            if (!isPlaying && audioBuffer) {
                startBackgroundLoop();
            }

            const now = audioCtx.currentTime;
            // Cancel any scheduled silence
            gateNode.gain.cancelScheduledValues(now);
            
            // Instantly jump to volume
            gateNode.gain.setValueAtTime(gateNode.gain.value, now);
            gateNode.gain.linearRampToValueAtTime(1.0, now + 0.005);
            
            // Decay back to silence.
            gateNode.gain.setTargetAtTime(0, now + 0.05, 0.25); 
        }

        // --- Game Logic ---

        class Ball {
            constructor(x, y, vx, vy, radius, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = radius;
                this.color = color || `hsl(${Math.random() * 360}, 85%, 60%)`;
                this.lastMultiplyTime = 0;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
                
                ctx.beginPath();
                ctx.arc(this.x - this.radius*0.3, this.y - this.radius*0.3, this.radius*0.25, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fill();
                ctx.closePath();
            }

            update() {
                this.vy += GRAVITY;
                
                // Only apply air friction if No Friction mode is OFF
                if (!modes.noFriction) {
                    this.vx *= FRICTION;
                }

                this.x += this.vx;
                this.y += this.vy;

                let bounced = false;
                let impactVelocity = 0;

                // Floor
                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    impactVelocity = Math.abs(this.vy);
                    // Always bounce if No Friction is ON, otherwise check velocity threshold
                    if (modes.noFriction || impactVelocity > 1) {
                        this.handleImpact('vertical');
                        bounced = true;
                    } else {
                        this.vy = 0;
                    }
                }
                // Ceiling
                else if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.handleImpact('vertical');
                    bounced = true;
                }

                // Walls
                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.handleImpact('horizontal');
                    bounced = true;
                } else if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.handleImpact('horizontal');
                    bounced = true;
                }

                return bounced;
            }

            handleImpact(axis) {
                openAudioGate();

                // --- Apply Physics ---
                let currentBounce = BASE_BOUNCE;
                
                if (modes.superBounce) {
                    currentBounce = SUPER_BOUNCE;
                } else if (modes.noFriction) {
                    currentBounce = 1.0; // Perfect elastic collision
                }
                
                if (axis === 'vertical') {
                    this.vy = -this.vy * currentBounce;
                } else {
                    this.vx = -this.vx * currentBounce;
                }

                // --- Strict Mode Application ---
                if (modes.speedUp === true) {
                    this.vx *= 1.10;
                    this.vy *= 1.10;
                    this.vx = Math.max(Math.min(this.vx, 50), -50);
                    this.vy = Math.max(Math.min(this.vy, 50), -50);
                }

                if (modes.grow === true) {
                    if (this.radius < 100) this.radius *= 1.05;
                }

                if (modes.multiply === true) {
                    const now = Date.now();
                    if ((Math.abs(this.vx) > 6 || Math.abs(this.vy) > 6) && now - this.lastMultiplyTime > 200) {
                        this.lastMultiplyTime = now;
                        return true;
                    }
                }

                return false;
            }
        }

        // --- Main Loop ---
        function loop() {
            ctx.fillStyle = 'rgba(15, 23, 42, 0.35)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let ballsToSpawn = 0;
            
            for (let i = 0; i < balls.length; i++) {
                let spawnRequested = balls[i].update();
                balls[i].draw();
                if (spawnRequested === true) ballsToSpawn++;
            }

            if (ballsToSpawn > 0 && modes.multiply === true) {
                let spawnLimit = Math.min(ballsToSpawn, 5); 
                for(let i = 0; i < spawnLimit; i++) {
                    if (balls.length >= MAX_BALLS) break;
                    const parent = balls[Math.floor(Math.random() * balls.length)];
                    balls.push(new Ball(
                        parent.x, parent.y,
                        (Math.random() - 0.5) * 15, 
                        -Math.abs(parent.vy) * 0.8, 
                        Math.max(8, parent.radius * 0.6),
                        parent.color
                    ));
                }
                document.getElementById('ballCount').textContent = `Balls: ${balls.length} (Max ${MAX_BALLS})`;
            }

            requestAnimationFrame(loop);
        }

        // --- Controls ---
        ['modeNoFriction', 'modeBounce', 'modeSpeed', 'modeGrow', 'modeMultiply'].forEach(id => {
             const el = document.getElementById(id);
             // Initial sync
             if(id === 'modeNoFriction') modes.noFriction = el.checked;
             if(id === 'modeBounce') modes.superBounce = el.checked;
             if(id === 'modeSpeed') modes.speedUp = el.checked;
             if(id === 'modeGrow') modes.grow = el.checked;
             if(id === 'modeMultiply') modes.multiply = el.checked;

             el.addEventListener('change', (e) => {
                 if(id === 'modeNoFriction') modes.noFriction = e.target.checked;
                 if(id === 'modeBounce') modes.superBounce = e.target.checked;
                 if(id === 'modeSpeed') modes.speedUp = e.target.checked;
                 if(id === 'modeGrow') modes.grow = e.target.checked;
                 if(id === 'modeMultiply') modes.multiply = e.target.checked;
             });
        });

        function addBall(x, y) {
            if (balls.length >= MAX_BALLS) return;
            x = x || Math.random() * (canvas.width - 50) + 25;
            y = y || 50;
            balls.push(new Ball(x, y, (Math.random() - 0.5) * 15, Math.random() * 5, 20 + Math.random() * 15));
            document.getElementById('ballCount').textContent = `Balls: ${balls.length} (Max ${MAX_BALLS})`;
        }

        // --- Interaction Handlers ---
        const handleInteract = async (e) => {
            e.preventDefault();
            await initAudio();
            if (audioBuffer && !isPlaying) startBackgroundLoop();
            document.getElementById('tutorial').style.opacity = '0';

            let x, y;
            if (e.type === 'mousedown' || e.type === 'click') {
                const rect = canvas.getBoundingClientRect();
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            } else if (e.type === 'touchstart') {
                const rect = canvas.getBoundingClientRect();
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            }
            
            if (e.target.id === 'startBtn') {
                 addBall(canvas.width/2, 100);
            } else {
                 addBall(x, y);
            }
        };

        document.getElementById('startBtn').addEventListener('click', handleInteract);
        canvas.addEventListener('mousedown', handleInteract);
        canvas.addEventListener('touchstart', handleInteract, {passive: false});

        document.getElementById('clearBtn').addEventListener('click', () => {
            balls = [];
            document.getElementById('ballCount').textContent = `Balls: 0 (Max ${MAX_BALLS})`;
        });

        loop();

    </script>
</body>
</html>
